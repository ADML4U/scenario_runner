#!/usr/bin/env python3

"""
CARLA Replay Script

This script replays recorded CARLA simulations with various configuration options.
It provides a simple interface to replay .log files generated by CARLA's recorder.
Additionally, it can export the replay as an MP4 video file.

Features:
- Replay CARLA recording files (.log)
- Export replay to MP4 video
- Configurable video resolution and frame rate
- Camera following specific vehicles or spectator view
- Detailed logging and error handling

Requirements for video recording:
- OpenCV: pip install opencv-python

Usage:
    python replay.py [options]

Examples:
    python replay.py --file PedestrianCrossing.log
    python replay.py --file recording.log --start 10.0 --duration 30.0 --follow 123
    python replay.py --file recording.log --video output.mp4
"""

import argparse
import os
import sys
import time
import logging
from datetime import datetime

try:
    import carla
except ImportError:
    print(
        "Error: CARLA Python API not found. Please ensure CARLA is properly installed."
    )
    sys.exit(1)

try:
    import cv2
    import numpy as np

    HAS_OPENCV = True
except ImportError:
    HAS_OPENCV = False

# pygame import removed as it's not used in this script


class VideoRecorder:
    """Handles video recording functionality for CARLA replay."""

    def __init__(self, output_path, fps=30, resolution=(1920, 1080)):
        """
        Initialize video recorder.

        Args:
            output_path (str): Path to save the MP4 file
            fps (int): Frames per second for the video
            resolution (tuple): Video resolution (width, height)
        """
        self.output_path = output_path
        self.fps = fps
        self.resolution = resolution
        self.recording = False
        self.frames = []
        self.video_writer = None
        self.camera_sensor = None
        self.world = None
        self.logger = logging.getLogger(__name__)

        if not HAS_OPENCV:
            raise ImportError(
                "OpenCV is required for video recording. Install with: pip install opencv-python"
            )

    def setup_camera(self, world, vehicle_id=None):
        """
        Setup camera sensor for recording.

        Args:
            world: CARLA world object
            vehicle_id (int): ID of vehicle to follow, None for spectator camera
        """
        self.world = world

        # Camera blueprint
        blueprint_library = world.get_blueprint_library()
        camera_bp = blueprint_library.find("sensor.camera.rgb")
        camera_bp.set_attribute("image_size_x", str(self.resolution[0]))
        camera_bp.set_attribute("image_size_y", str(self.resolution[1]))
        camera_bp.set_attribute("fov", "90")

        # Camera transform
        if vehicle_id:
            # Follow specific vehicle
            vehicle = world.get_actor(vehicle_id)
            if vehicle:
                camera_transform = carla.Transform(
                    carla.Location(x=-8.0, z=6.0), carla.Rotation(pitch=-15)
                )
                self.camera_sensor = world.spawn_actor(
                    camera_bp, camera_transform, attach_to=vehicle
                )
            else:
                self.logger.warning(
                    f"Vehicle {vehicle_id} not found, using spectator camera"
                )
                self._setup_spectator_camera()
        else:
            # Use spectator camera position
            self._setup_spectator_camera()

        if self.camera_sensor:
            self.camera_sensor.listen(self._on_camera_data)
            self.logger.info("Camera sensor setup complete")

    def _setup_spectator_camera(self):
        """Setup camera at spectator position."""
        spectator = self.world.get_spectator()
        camera_transform = spectator.get_transform()

        blueprint_library = self.world.get_blueprint_library()
        camera_bp = blueprint_library.find("sensor.camera.rgb")
        camera_bp.set_attribute("image_size_x", str(self.resolution[0]))
        camera_bp.set_attribute("image_size_y", str(self.resolution[1]))
        camera_bp.set_attribute("fov", "90")

        self.camera_sensor = self.world.spawn_actor(camera_bp, camera_transform)

    def _on_camera_data(self, image):
        """Callback for camera data."""
        if self.recording:
            # Convert CARLA image to numpy array
            array = np.frombuffer(image.raw_data, dtype=np.dtype("uint8"))
            array = np.reshape(array, (image.height, image.width, 4))
            array = array[:, :, :3]  # Remove alpha channel
            array = array[:, :, ::-1]  # Convert BGR to RGB

            self.frames.append(array.copy())

    def start_recording(self):
        """Start video recording."""
        self.recording = True
        self.frames = []
        self.logger.info(f"Started video recording to {self.output_path}")

    def stop_recording(self):
        """Stop recording and save video."""
        self.recording = False

        if self.frames:
            self.logger.info(f"Saving video with {len(self.frames)} frames...")

            # Initialize video writer
            fourcc = cv2.VideoWriter_fourcc(*"mp4v")
            self.video_writer = cv2.VideoWriter(
                self.output_path, fourcc, self.fps, self.resolution
            )

            # Write frames
            for frame in self.frames:
                self.video_writer.write(frame)

            self.video_writer.release()
            self.logger.info(f"Video saved to {self.output_path}")
        else:
            self.logger.warning("No frames recorded")

    def cleanup(self):
        """Clean up camera sensor."""
        if self.camera_sensor:
            self.camera_sensor.destroy()
            self.camera_sensor = None


class CarlaReplayManager:
    """Manages CARLA replay functionality with error handling and configuration."""

    def __init__(self, host="127.0.0.1", port=2000, timeout=10.0):
        """
        Initialize the replay manager.

        Args:
            host (str): CARLA server host address
            port (int): CARLA server port
            timeout (float): Connection timeout in seconds
        """
        self.host = host
        self.port = port
        self.timeout = timeout
        self.client = None
        self.world = None
        self.video_recorder = None

        # Setup logging
        logging.basicConfig(
            level=logging.INFO, format="%(asctime)s - %(levelname)s - %(message)s"
        )
        self.logger = logging.getLogger(__name__)

    def connect(self):
        """Establish connection to CARLA server."""
        try:
            self.logger.info(f"Connecting to CARLA server at {self.host}:{self.port}")
            self.client = carla.Client(self.host, self.port)
            self.client.set_timeout(self.timeout)

            # Test connection by getting world
            self.world = self.client.get_world()
            self.logger.info("Successfully connected to CARLA server")
            return True

        except Exception as e:
            self.logger.error(f"Failed to connect to CARLA server: {e}")
            return False

    def validate_recording_file(self, filename):
        """
        Validate that the recording file exists and is accessible.

        Args:
            filename (str): Path to the recording file

        Returns:
            bool: True if file is valid, False otherwise
        """
        if not os.path.exists(filename):
            self.logger.error(f"Recording file not found: {filename}")
            return False

        if not filename.endswith(".log"):
            self.logger.warning(f"File {filename} doesn't have .log extension")

        file_size = os.path.getsize(filename)
        if file_size == 0:
            self.logger.error(f"Recording file is empty: {filename}")
            return False

        self.logger.info(f"Recording file validated: {filename} ({file_size} bytes)")
        return True

    def show_recording_info(self, filename):
        """
        Display information about the recording file.

        Args:
            filename (str): Path to the recording file
        """
        try:
            info = self.client.show_recorder_file_info(filename, False)
            self.logger.info("Recording file information:")
            print(info)
        except Exception as e:
            self.logger.error(f"Failed to get recording info: {e}")

    def replay_file(
        self,
        filename,
        start_time=0.0,
        duration=0.0,
        follow_id=0,
        replay_sensors=False,
        video_output=None,
        video_fps=30,
        video_resolution=(1920, 1080),
    ):
        """
        Replay a CARLA recording file.

        Args:
            filename (str): Path to the recording file
            start_time (float): Start time in seconds (0 = from beginning, negative = from end)
            duration (float): Duration to replay in seconds (0 = entire recording)
            follow_id (int): Actor ID to follow with camera (0 = no camera)
            replay_sensors (bool): Whether to replay sensor data
            video_output (str): Path to save MP4 video (None = no video recording)
            video_fps (int): Video frame rate
            video_resolution (tuple): Video resolution (width, height)
        """
        if not self.validate_recording_file(filename):
            return False

        try:
            self.logger.info(f"Starting replay of {filename}")
            self.logger.info(
                f"Parameters: start={start_time}s, duration={duration}s, follow_id={follow_id}"
            )

            # Show recording information
            self.show_recording_info(filename)

            # Setup video recording if requested
            if video_output:
                if not HAS_OPENCV:
                    self.logger.error(
                        "OpenCV not available. Install with: pip install opencv-python"
                    )
                    return False

                self.video_recorder = VideoRecorder(
                    video_output, video_fps, video_resolution
                )
                # Use follow_id for camera if it's specified, otherwise use spectator
                camera_vehicle_id = follow_id if follow_id > 0 else None
                self.video_recorder.setup_camera(self.world, camera_vehicle_id)

                # Wait a moment for camera to initialize
                time.sleep(2.0)
                self.video_recorder.start_recording()

            # Start replay
            result = self.client.replay_file(
                filename, start_time, duration, follow_id, replay_sensors
            )

            if result:
                self.logger.info("Replay started successfully")
                if video_output:
                    self.logger.info(f"Recording video to {video_output}")
                self.logger.info("Press Ctrl+C to stop replay")

                # Keep the script running while replay is active
                try:
                    replay_start_time = time.time()
                    while True:
                        time.sleep(0.1)  # Shorter sleep for better video capture

                        # Check if duration has elapsed
                        if duration > 0:
                            elapsed = time.time() - replay_start_time
                            if elapsed >= duration:
                                self.logger.info("Replay duration completed")
                                break

                except KeyboardInterrupt:
                    self.logger.info("Replay interrupted by user")

                # Stop video recording
                if self.video_recorder:
                    self.video_recorder.stop_recording()
                    self.video_recorder.cleanup()
                    self.video_recorder = None

                self.stop_replay()

            else:
                self.logger.error("Failed to start replay")
                return False

        except Exception as e:
            self.logger.error(f"Error during replay: {e}")
            # Cleanup video recorder on error
            if self.video_recorder:
                self.video_recorder.cleanup()
                self.video_recorder = None
            return False

        return True

    def stop_replay(self, keep_actors=False):
        """
        Stop the current replay.

        Args:
            keep_actors (bool): Whether to keep actors after stopping replay
        """
        try:
            self.client.stop_replayer(keep_actors)
            self.logger.info("Replay stopped")
        except Exception as e:
            self.logger.error(f"Error stopping replay: {e}")

    def list_available_recordings(self, directory="local_rss/recordings"):
        """
        List available recording files in the specified directory.

        Args:
            directory (str): Directory to search for recordings
        """
        if not os.path.exists(directory):
            self.logger.warning(f"Recordings directory not found: {directory}")
            return []

        recordings = []
        for file in os.listdir(directory):
            if file.endswith(".log"):
                full_path = os.path.join(directory, file)
                size = os.path.getsize(full_path)
                recordings.append((file, full_path, size))

        if recordings:
            self.logger.info("Available recordings:")
            for name, path, size in recordings:
                print(f"  {name} ({size} bytes)")
        else:
            self.logger.info("No recording files found")

        return recordings


def main():
    """Main function to handle command line arguments and run replay."""
    parser = argparse.ArgumentParser(
        description="CARLA Replay Script - Replay recorded CARLA simulations",
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog="""
Examples:
  %(prog)s --file PedestrianCrossing.log
  %(prog)s --file recording.log --start 10.0 --duration 30.0
  %(prog)s --file recording.log --follow 123 --sensors
  %(prog)s --file recording.log --video output.mp4
  %(prog)s --file recording.log --video output.mp4 --fps 60 --resolution 1280x720
  %(prog)s --file recording.log --video output.mp4 --camera-follow 123
  %(prog)s --list
        """,
    )

    parser.add_argument(
        "--file", "-f", type=str, help="Path to the recording file to replay"
    )

    parser.add_argument(
        "--start",
        "-s",
        type=float,
        default=0.0,
        help="Start time in seconds (default: 0.0, negative values start from end)",
    )

    parser.add_argument(
        "--duration",
        "-d",
        type=float,
        default=0.0,
        help="Duration to replay in seconds (default: 0.0 = entire recording)",
    )

    parser.add_argument(
        "--follow",
        "-F",
        type=int,
        default=0,
        help="Actor ID to follow with camera (default: 0 = no camera)",
    )

    parser.add_argument(
        "--sensors", action="store_true", help="Replay sensor data (default: False)"
    )

    parser.add_argument(
        "--host",
        type=str,
        default="127.0.0.1",
        help="CARLA server host (default: 127.0.0.1)",
    )

    parser.add_argument(
        "--port", "-p", type=int, default=2000, help="CARLA server port (default: 2000)"
    )

    parser.add_argument(
        "--timeout",
        "-t",
        type=float,
        default=10.0,
        help="Connection timeout in seconds (default: 10.0)",
    )

    parser.add_argument(
        "--list", "-l", action="store_true", help="List available recording files"
    )

    parser.add_argument(
        "--info", "-i", type=str, help="Show information about a recording file"
    )

    # Video recording options
    parser.add_argument(
        "--video", "-v", type=str, help="Save replay as MP4 video to specified path"
    )

    parser.add_argument(
        "--fps", type=int, default=30, help="Video frame rate (default: 30)"
    )

    parser.add_argument(
        "--resolution",
        type=str,
        default="1920x1080",
        help="Video resolution in WIDTHxHEIGHT format (default: 1920x1080)",
    )

    parser.add_argument(
        "--camera-follow",
        type=int,
        default=0,
        help="Vehicle ID to follow with camera for video recording (default: 0 = spectator)",
    )

    args = parser.parse_args()

    # Parse video resolution
    video_resolution = (1920, 1080)
    if args.resolution:
        try:
            width, height = map(int, args.resolution.split("x"))
            video_resolution = (width, height)
        except ValueError:
            print(
                f"Invalid resolution format: {args.resolution}. Use WIDTHxHEIGHT (e.g., 1920x1080)"
            )
            sys.exit(1)

    # Validate video output path
    video_output = None
    if args.video:
        video_output = args.video
        if not video_output.endswith(".mp4"):
            video_output += ".mp4"

        # Create directory if it doesn't exist
        video_dir = os.path.dirname(video_output)
        if video_dir and not os.path.exists(video_dir):
            os.makedirs(video_dir)

        # Check OpenCV availability
        if not HAS_OPENCV:
            print("Error: OpenCV is required for video recording.")
            print("Install with: pip install opencv-python")
            sys.exit(1)

    # Create replay manager
    replay_manager = CarlaReplayManager(args.host, args.port, args.timeout)

    # Connect to CARLA
    if not replay_manager.connect():
        sys.exit(1)

    # Handle different operations
    if args.list:
        replay_manager.list_available_recordings()
        return

    if args.info:
        if replay_manager.validate_recording_file(args.info):
            replay_manager.show_recording_info(args.info)
        return

    if not args.file:
        # If no file specified, try to use default
        default_file = "local_rss/recordings/PedestrianCrossing.log"
        if os.path.exists(default_file):
            print(f"No file specified, using default: {default_file}")
            args.file = default_file
        else:
            print("Error: No recording file specified and default file not found")
            print(
                "Use --file to specify a recording file or --list to see available files"
            )
            sys.exit(1)

    # Generate default video filename if video recording is requested but no path specified
    if args.video == "":
        timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
        recording_name = os.path.splitext(os.path.basename(args.file))[0]
        video_output = f"replay_{recording_name}_{timestamp}.mp4"

    # Note: camera_follow argument is available but currently using follow_id for camera positioning

    # Start replay
    success = replay_manager.replay_file(
        filename=args.file,
        start_time=args.start,
        duration=args.duration,
        follow_id=args.follow,
        replay_sensors=args.sensors,
        video_output=video_output,
        video_fps=args.fps,
        video_resolution=video_resolution,
    )

    if not success:
        sys.exit(1)


if __name__ == "__main__":
    main()
